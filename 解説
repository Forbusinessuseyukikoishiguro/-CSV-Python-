#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
テキストデータをCSVデータに変換するGUIツール

【新人エンジニア向け学習版】
このファイルは新人エンジニアの学習用に、各行に詳細なコメントを付けています。
コメントを読みながら、Pythonの基本文法やGUIプログラミングを学習できます。

作成者: [あなたの名前]
更新日: 2024-08-08
目的: 業務効率化・残業削減
"""

# ============================================================================
# 1. ライブラリインポート部分
# 必要な機能を提供するライブラリを読み込みます
# ============================================================================

import tkinter as tk  # GUI作成の基本ライブラリ（Python標準）
from tkinter import ttk, filedialog, messagebox, scrolledtext  # tkinterの拡張機能
# ttk: よりモダンなウィジェット（ボタン、ラベルなど）
# filedialog: ファイル選択ダイアログ
# messagebox: エラーや成功メッセージの表示
# scrolledtext: スクロール可能なテキストエリア

import csv  # CSVファイルを扱うためのライブラリ（Python標準）
import re   # 正規表現を使うためのライブラリ（Python標準）
import os   # ファイルシステム操作用（今回は直接使用しないが念のため）
from pathlib import Path  # ファイルパスを扱いやすくするライブラリ
from typing import List, Dict, Any, Optional  # 型ヒント用（コードを読みやすくする）

# ============================================================================
# 2. メインクラス定義
# Pythonではclass（クラス）を使ってプログラムを整理します
# ============================================================================

class TextToCSVConverterGUI:
    """
    テキストデータをCSVに変換するGUIアプリケーション
    
    【クラスとは？】
    関連する機能をまとめた「設計図」のようなもの。
    例：この車クラスには「走る」「止まる」「曲がる」機能がある、みたいな感じ。
    
    【このクラスの役割】
    - ファイル選択画面を作る
    - テキストを解析してCSVに変換する
    - ユーザーに結果を表示する
    """
    
    def __init__(self, root):
        """
        クラスの初期化メソッド（コンストラクタ）
        
        【__init__とは？】
        クラスが作られた時に最初に実行される特別なメソッド。
        「新しい車を製造する時に、必ずタイヤ4個とエンジン1個を付ける」みたいな感じ。
        
        Args:
            root: tkinterのメインウィンドウオブジェクト
        """
        self.root = root  # メインウィンドウへの参照を保存
        self.root.title("テキスト→CSV変換ツール")  # ウィンドウのタイトルバーに表示される文字
        self.root.geometry("900x700")  # ウィンドウサイズ（横900px × 縦700px）
        
        # ============================================================================
        # 3. 変数の初期化
        # アプリで使用する変数を準備します（tkinter用の特別な変数）
        # ============================================================================
        
        # StringVar()は、tkinterのGUI部品と連動する文字列変数
        # 普通の変数と違い、GUI部品の値と自動で同期される便利な仕組み
        self.input_file_path = tk.StringVar()      # 入力ファイルのパス
        self.output_file_path = tk.StringVar()     # 出力ファイルのパス  
        self.parse_mode = tk.StringVar(value="auto")  # 解析モード（初期値：auto）
        self.delimiter = tk.StringVar()            # 区切り文字（タブ、カンマなど）
        self.pattern = tk.StringVar()              # 正規表現パターン
        self.widths = tk.StringVar()               # 固定幅の列幅設定
        self.headers = tk.StringVar()              # CSVのヘッダー行
        self.encoding = tk.StringVar(value="utf-8")  # ファイルエンコーディング（初期値：UTF-8）
        
        self.preview_data = []  # プレビュー用のデータを保存するリスト（普通のPython変数）
        self.setup_ui()  # UIセットアップメソッドを呼び出し（画面を作る）
    
    def setup_ui(self):
        """
        ユーザーインターフェース（UI）をセットアップする
        
        【メソッドとは？】
        クラスの中に定義された関数のこと。そのクラスの「能力」や「行動」を表す。
        例：車クラスの「運転する()」メソッド
        
        【このメソッドの役割】
        画面の部品（ボタン、テキストボックスなど）を配置する
        """
        # メインフレーム（全体の枠）を作成
        main_frame = ttk.Frame(self.root, padding="10")  # padding="10"で周囲に10pxの余白
        # gridメソッドで部品を格子状に配置（sticky=方向で引き伸ばし）
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        # W=West(左), E=East(右), N=North(上), S=South(下)
        
        # 各エリアを作成（メソッドに分けることで、コードを読みやすくしている）
        self.create_file_selection_area(main_frame)  # ファイル選択エリア
        self.create_settings_area(main_frame)        # 設定エリア
        self.create_preview_area(main_frame)         # プレビューエリア
        self.create_button_area(main_frame)          # ボタンエリア
        self.create_status_area(main_frame)          # ステータスバー
        
        # グリッドの重み設定（ウィンドウサイズ変更時の伸縮を制御）
        self.root.columnconfigure(0, weight=1)      # 列0を伸縮可能に
        self.root.rowconfigure(0, weight=1)         # 行0を伸縮可能に  
        main_frame.columnconfigure(1, weight=1)     # メインフレーム内の列1を伸縮可能に
        main_frame.rowconfigure(3, weight=1)        # メインフレーム内の行3（プレビューエリア）を伸縮可能に
    
    def create_file_selection_area(self, parent):
        """
        ファイル選択エリアを作成
        
        Args:
            parent: このエリアを配置する親ウィジェット
            
        【重要な概念：親子関係】
        GUI部品は親子関係で管理される。
        例：ウィンドウ（親） → フレーム（子） → ボタン（孫）
        """
        # LabelFrame = 枠線とタイトル付きの領域
        file_frame = ttk.LabelFrame(parent, text="ファイル選択", padding="5")
        # columnspan=2 で2列分の幅を占有
        file_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        file_frame.columnconfigure(1, weight=1)  # 列1（ファイルパス表示）を伸縮可能に
        
        # ============================================================================
        # 入力ファイル選択行
        # ============================================================================
        
        # ラベル：「入力ファイル:」という文字を表示
        ttk.Label(file_frame, text="入力ファイル:").grid(
            row=0, column=0,           # 行0、列0に配置
            sticky=tk.W,               # 左寄せ
            padx=(0, 5)               # 左0px、右5pxの余白
        )
        
        # エントリー：ファイルパスを表示するテキストボックス
        ttk.Entry(file_frame, 
                 textvariable=self.input_file_path,  # StringVar変数と連動
                 width=50                            # 幅50文字分
        ).grid(
            row=0, column=1,           # 行0、列1に配置
            sticky=(tk.W, tk.E),       # 左右に引き伸ばし
            padx=(0, 5)               # 左0px、右5pxの余白
        )
        
        # ボタン：「参照」ボタン（クリックでファイル選択ダイアログ表示）
        ttk.Button(file_frame, 
                  text="参照", 
                  command=self.browse_input_file  # クリック時に実行するメソッド
        ).grid(row=0, column=2)  # 行0、列2に配置
        
        # ============================================================================
        # 出力ファイル選択行（入力ファイルとほぼ同じ構造）
        # ============================================================================
        
        ttk.Label(file_frame, text="出力ファイル:").grid(
            row=1, column=0, 
            sticky=tk.W, 
            padx=(0, 5), 
            pady=(5, 0)  # 上5px、下0pxの余白（行間を空ける）
        )
        
        ttk.Entry(file_frame, 
                 textvariable=self.output_file_path, 
                 width=50
        ).grid(
            row=1, column=1, 
            sticky=(tk.W, tk.E), 
            padx=(0, 5), 
            pady=(5, 0)
        )
        
        ttk.Button(file_frame, 
                  text="参照", 
                  command=self.browse_output_file
        ).grid(row=1, column=2, pady=(5, 0))
    
    def create_settings_area(self, parent):
        """
        変換設定エリアを作成
        
        【このエリアの役割】
        ユーザーがデータの解析方法を選択できるようにする
        """
        settings_frame = ttk.LabelFrame(parent, text="変換設定", padding="5")
        settings_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        settings_frame.columnconfigure(1, weight=1)
        
        # ============================================================================
        # 解析モード選択（コンボボックス = ドロップダウンメニュー）
        # ============================================================================
        
        ttk.Label(settings_frame, text="解析モード:").grid(
            row=0, column=0, 
            sticky=tk.W, 
            padx=(0, 5)
        )
        
        # Combobox = ドロップダウンメニュー（選択肢から1つ選ぶ）
        mode_combo = ttk.Combobox(settings_frame, 
                                 textvariable=self.parse_mode,  # 選択された値を保存する変数
                                 width=15
        )
        # valuesプロパティで選択肢を設定
        mode_combo['values'] = ('auto', 'structured', 'key_value', 'pattern', 'fixed_width')
        mode_combo.grid(row=0, column=1, sticky=tk.W, padx=(0, 10))
        
        # bind = イベント処理（何かが起こった時の処理を登録）
        # <<ComboboxSelected>> = コンボボックスで選択が変更された時
        mode_combo.bind('<<ComboboxSelected>>', self.on_mode_changed)
        
        # ============================================================================
        # エンコーディング選択
        # ============================================================================
        
        ttk.Label(settings_frame, text="エンコーディング:").grid(
            row=0, column=2, 
            sticky=tk.W, 
            padx=(10, 5)
        )
        
        encoding_combo = ttk.Combobox(settings_frame, 
                                     textvariable=self.encoding, 
                                     width=10
        )
        # 日本語でよく使われるエンコーディングを選択肢に
        encoding_combo['values'] = ('utf-8', 'shift_jis', 'cp932', 'euc-jp')
        encoding_combo.grid(row=0, column=3, sticky=tk.W)
        
        # ============================================================================
        # モード固有のコントロール（最初は非表示、必要に応じて表示）
        # ============================================================================
        
        # 区切り文字設定（structuredモード用）
        self.delimiter_label = ttk.Label(settings_frame, text="区切り文字:")
        self.delimiter_entry = ttk.Entry(settings_frame, textvariable=self.delimiter, width=10)
        
        # 正規表現パターン設定（patternモード用）
        self.pattern_label = ttk.Label(settings_frame, text="正規表現:")
        self.pattern_entry = ttk.Entry(settings_frame, textvariable=self.pattern, width=30)
        
        # 列幅設定（fixed_widthモード用）
        self.widths_label = ttk.Label(settings_frame, text="列幅(カンマ区切り):")
        self.widths_entry = ttk.Entry(settings_frame, textvariable=self.widths, width=20)
        
        # ============================================================================
        # ヘッダー設定（全モード共通）
        # ============================================================================
        
        ttk.Label(settings_frame, text="ヘッダー(カンマ区切り):").grid(
            row=2, column=0, 
            sticky=tk.W, 
            padx=(0, 5), 
            pady=(5, 0)
        )
        
        # columnspan=3 で3列分の幅を占有
        ttk.Entry(settings_frame, 
                 textvariable=self.headers, 
                 width=40
        ).grid(
            row=2, column=1, 
            columnspan=3, 
            sticky=(tk.W, tk.E), 
            pady=(5, 0)
        )
        
        # 初期状態では追加設定を非表示にする
        self.update_mode_specific_controls()
    
    def create_preview_area(self, parent):
        """
        プレビューエリアを作成
        
        【プレビューとは？】
        変換前に結果を確認できる機能。失敗を防ぐために重要。
        """
        preview_frame = ttk.LabelFrame(parent, text="プレビュー", padding="5")
        preview_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        preview_frame.columnconfigure(0, weight=1)  # 列0を伸縮可能に
        preview_frame.rowconfigure(1, weight=1)     # 行1（テキストエリア）を伸縮可能に
        
        # プレビュー更新ボタン
        ttk.Button(preview_frame, 
                  text="プレビュー更新", 
                  command=self.update_preview
        ).grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        
        # ScrolledText = スクロールバー付きのテキストエリア
        self.preview_text = scrolledtext.ScrolledText(preview_frame, 
                                                     height=15,  # 高さ15行
                                                     width=80    # 幅80文字
        )
        self.preview_text.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
    
    def create_button_area(self, parent):
        """
        ボタンエリアを作成（実行、クリア、サンプル読込ボタン）
        """
        button_frame = ttk.Frame(parent)  # ボタン専用のフレーム
        button_frame.grid(row=3, column=0, columnspan=2, pady=(0, 10))
        
        # pack = 部品を順番に並べる配置方法（gridとは別の方式）
        # side=tk.LEFT で左から順番に配置
        ttk.Button(button_frame, 
                  text="変換実行", 
                  command=self.convert_file, 
                  style="Accent.TButton"  # 強調スタイル（青色など）
        ).pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(button_frame, 
                  text="クリア", 
                  command=self.clear_all
        ).pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Button(button_frame, 
                  text="サンプル読込", 
                  command=self.load_sample
        ).pack(side=tk.LEFT)
    
    def create_status_area(self, parent):
        """
        ステータスバーを作成（現在の処理状況を表示）
        """
        self.status_var = tk.StringVar(value="準備完了")  # 初期状態は「準備完了」
        
        status_frame = ttk.Frame(parent)
        status_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E))
        status_frame.columnconfigure(0, weight=1)
        
        # relief=tk.SUNKEN でくぼんだ見た目にする（ステータスバーらしく）
        ttk.Label(status_frame, 
                 textvariable=self.status_var, 
                 relief=tk.SUNKEN
        ).grid(row=0, column=0, sticky=(tk.W, tk.E))
    
    # ============================================================================
    # 4. イベント処理メソッド群
    # ユーザーの操作（ボタンクリックなど）に応答する処理
    # ============================================================================
    
    def browse_input_file(self):
        """
        入力ファイル選択ダイアログを表示
        
        【ファイルダイアログとは？】
        「ファイルを開く」でよく見る、ファイル選択画面のこと
        """
        # askopenfilename = ファイルを開くダイアログ
        filename = filedialog.askopenfilename(
            title="入力テキストファイルを選択",    # ダイアログのタイトル
            filetypes=[                              # 表示するファイル種類
                ("テキストファイル", "*.txt"), 
                ("すべてのファイル", "*.*")
            ]
        )
        
        # ファイルが選択された場合（キャンセルされた場合はNoneまたは空文字）
        if filename:
            self.input_file_path.set(filename)  # StringVar変数に値を設定
            
            # 出力ファイル名を自動生成（便利機能）
            if not self.output_file_path.get():  # 出力ファイルが未設定の場合
                base_name = Path(filename).stem  # ファイル名から拡張子を除いた部分
                # 元ファイルと同じフォルダに「_converted.csv」を付けたファイル名を生成
                output_path = Path(filename).parent / f"{base_name}_converted.csv"
                self.output_file_path.set(str(output_path))  # 文字列に変換して設定
    
    def browse_output_file(self):
        """
        出力ファイル選択ダイアログを表示
        """
        # asksaveasfilename = 名前を付けて保存ダイアログ
        filename = filedialog.asksaveasfilename(
            title="出力CSVファイルを選択",
            defaultextension=".csv",  # デフォルトの拡張子
            filetypes=[("CSVファイル", "*.csv"), ("すべてのファイル", "*.*")]
        )
        if filename:
            self.output_file_path.set(filename)
    
    def on_mode_changed(self, event=None):
        """
        解析モードが変更された時の処理
        
        Args:
            event: tkinterのイベント情報（今回は使用しない）
        """
        self.update_mode_specific_controls()
    
    def update_mode_specific_controls(self):
        """
        選択された解析モードに応じて、必要な設定項目だけを表示
        
        【動的UI制御】
        ユーザーの選択に応じて画面を変化させる技術。
        不要な項目を隠すことで、画面をシンプルに保つ。
        """
        # まず既存のコントロールをすべて非表示にする
        for widget in [self.delimiter_label, self.delimiter_entry, 
                      self.pattern_label, self.pattern_entry,
                      self.widths_label, self.widths_entry]:
            widget.grid_remove()  # grid_remove()で一時的に非表示（完全削除ではない）
        
        mode = self.parse_mode.get()  # 現在選択されているモードを取得
        settings_frame = self.delimiter_label.master  # 親フレームを取得
        
        # 選択されたモードに応じて、必要なコントロールのみ表示
        if mode == 'structured':
            # 構造化データモード：区切り文字の設定が必要
            self.delimiter_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 5), pady=(5, 0))
            self.delimiter_entry.grid(row=1, column=1, sticky=tk.W, pady=(5, 0))
            
        elif mode == 'pattern':
            # 正規表現モード：パターンの設定が必要
            self.pattern_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 5), pady=(5, 0))
            self.pattern_entry.grid(row=1, column=1, columnspan=3, sticky=(tk.W, tk.E), pady=(5, 0))
            
        elif mode == 'fixed_width':
            # 固定幅モード：列幅の設定が必要
            self.widths_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 5), pady=(5, 0))
            self.widths_entry.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))
    
    # ============================================================================
    # 5. データ解析メソッド群
    # 様々な形式のテキストデータを解析してリスト形式に変換
    # ============================================================================
    
    def parse_structured_text(self, text: str, delimiter: str = None) -> List[List[str]]:
        """
        構造化されたテキストを解析（タブ区切り、カンマ区切りなど）
        
        Args:
            text: 解析するテキストデータ
            delimiter: 区切り文字（Noneの場合は自動検出）
            
        Returns:
            List[List[str]]: 2次元リスト（行×列のデータ）
            
        【型ヒントについて】
        -> List[List[str]] は「文字列のリストのリストを返す」という意味
        例：[["田中", "30"], ["佐藤", "25"]] みたいなデータ
        """
        lines = text.strip().split('\n')  # 改行で分割してリストにする
        data = []  # 結果を保存するリスト
        
        # 各行を処理
        for line in lines:
            if not line.strip():  # 空行はスキップ
                continue
                
            if delimiter:
                # 区切り文字が指定されている場合
                row = [cell.strip() for cell in line.split(delimiter)]
                # strip()で前後の空白を除去
                # リスト内包表記：[式 for 変数 in リスト] で簡潔に書ける
                
            else:
                # 自動検出の場合
                if '\t' in line:
                    # タブ文字が含まれていればタブ区切り
                    row = [cell.strip() for cell in line.split('\t')]
                elif ',' in line and line.count(',') >= 2:
                    # カンマが2個以上あればカンマ区切り
                    row = [cell.strip() for cell in line.split(',')]
                else:
                    # 複数のスペースで区切られている場合
                    row = re.split(r'\s{2,}', line.strip())  # 2個以上の空白文字で分割
                    if len(row) == 1:
                        # 単一スペースの場合
                        row = line.split()
            
            data.append(row)  # 処理した行をデータに追加
        
        return data
    
    def parse_key_value_text(self, text: str) -> List[List[str]]:
        """
        キー：値形式のテキストを解析
        
        例：
        名前：田中太郎
        年齢：30
        職業：エンジニア
        """
        lines = text.strip().split('\n')
        data = []
        
        for line in lines:
            if not line.strip():
                continue
            
            # 様々な区切り文字に対応
            separators = ['：', ':', '=', '\t']  # 全角コロン、半角コロン、等号、タブ
            for sep in separators:
                if sep in line:
                    parts = line.split(sep, 1)  # 最初の区切り文字でのみ分割（maxsplit=1）
                    if len(parts) == 2:
                        key = parts[0].strip()    # キー部分
                        value = parts[1].strip()  # 値部分
                        data.append([key, value])
                    break  # 見つかったら他の区切り文字は試さない
        
        return data
    
    def parse_pattern_text(self, text: str, pattern: str) -> List[List[str]]:
        """
        正規表現パターンを使用してテキストを解析
        
        【正規表現とは？】
        文字列のパターンを表現する記法。
        例：\d{4} = 4桁の数字、(.+) = 任意の文字列をグループ化
        """
        lines = text.strip().split('\n')
        data = []
        
        try:
            regex = re.compile(pattern)  # 正規表現パターンをコンパイル（高速化のため）
            for line in lines:
                match = regex.search(line)  # パターンにマッチする部分を検索
                if match:
                    groups = match.groups()  # マッチした部分のグループを取得
                    data.append(list(groups))  # タプルをリストに変換
        except re.error as e:
            # 正規表現の構文エラーの場合
            raise ValueError(f"正規表現エラー: {e}")
        
        return data
    
    def parse_fixed_width_text(self, text: str, widths: List[int]) -> List[List[str]]:
        """
        固定幅テキストを解析
        
        例：
        田中太郎    30   エンジニア部
        佐藤花子    25   デザイン部
        
        Args:
            widths: 各列の文字数のリスト [15, 5, 15] など
        """
        lines = text.strip().split('\n')
        data = []
        
        for line in lines:
            if not line.strip():
                continue
            
            row = []
            start = 0  # 切り出し開始位置
            for width in widths:
                end = start + width  # 切り出し終了位置
                # スライス [start:end] で文字列の一部を取得
                cell = line[start:end].strip() if end <= len(line) else line[start:].strip()
                row.append(cell)
                start = end  # 次の列の開始位置
            
            data.append(row)
        
        return data
    
    # ============================================================================
    # 6. プレビュー機能
    # 変換前に結果を確認できる重要な機能
    # ============================================================================
    
    def update_preview(self):
        """
        プレビューを更新（ファイルを読み込んで解析結果を表示）
        
        【エラーハンドリング】
        try-except文で例外（エラー）を適切に処理する
        """
        if not self.input_file_path.get():
            # ファイルが選択されていない場合の警告
            messagebox.showwarning("警告", "入力ファイルを選択してください。")
            return
        
        try:
            self.status_var.set("プレビュー生成中...")  # ステータス更新
            self.root.update()  # GUI更新（ユーザーに進行状況を表示）
            
            # ファイル読み込み
            with open(self.input_file_path.get(), 'r', encoding=self.encoding.get()) as f:
                text = f.read()
            # with文：ファイルの自動クローズを保証（重要な書き方）
            
            # 選択された解析モードに応じて処理
            mode = self.parse_mode.get()
            
            if mode == 'structured' or mode == 'auto':
                data = self.parse_structured_text(text, self.delimiter.get() or None)
                # self.delimiter.get() or None: 空文字の場合はNoneにする
                
            elif mode == 'key_value':
                data = self.parse_key_value_text(text)
                
            elif mode == 'pattern':
                if not self.pattern.get():
                    messagebox.showerror("エラー", "正規表現パターンを入力してください。")
                    return
                data = self.parse_pattern_text(text, self.pattern.get())
                
            elif mode == 'fixed_width':
                if not self.widths.get():
                    messagebox.showerror("エラー", "列幅を入力してください。")
                    return
                try:
                    # 文字列から整数リストに変換 "10,5,15" → [10, 5, 15]
                    widths = [int(w.strip()) for w in self.widths.get().split(',')]
                    data = self.parse_fixed_width_text(text, widths)
                except ValueError:
                    messagebox.showerror("エラー", "列幅は整数をカンマ区切りで入力してください。")
                    return
            
            # プレビュー表示
            self.preview_data = data  # 後で変換処理で使用するため保存
            self.display_preview(data)
            self.status_var.set(f"プレビュー完了: {len(data)}行のデータを解析しました。")
            
        except FileNotFoundError:
            messagebox.showerror("エラー", f"ファイル '{self.input_file_path.get()}' が見つかりません。")
        except UnicodeDecodeError:
            messagebox.showerror("エラー", "ファイルのエンコーディングが正しくありません。")
        except Exception as e:
            # 予期しないエラーの場合
            messagebox.showerror("エラー", f"プレビュー生成中にエラーが発生しました: {e}")
            self.status_var.set("エラーが発生しました。")
    
    def display_preview(self, data: List[List[str]]):
        """
        プレビューデータをテキストエリアに表示
        
        Args:
            data: 表示するデータ（2次元リスト）
        """
        self.preview_text.delete(1.0, tk.END)  # 既存の内容をクリア
        # 1.0 = 1行目の0文字目、tk.END = 最後まで
        
        if not data:
            self.preview_text.insert(tk.END, "解析可能なデータが見つかりませんでした。")
            return
        
        # ヘッダー行の表示
        headers = None
        if self.headers.get():
            headers = [h.strip() for h in self.headers.get().split(',')]
            header_line = ','.join(headers) + '\n'
            self.preview_text.insert(tk.END, f"[ヘッダー] {header_line}")
        
        # データ行の表示（最初の10行まで）
        max_preview_rows = 10
        for i, row in enumerate(data[:max_preview_rows]):  # enumerate = インデックス付きループ
            # CSV形式の文字列を作成
            csv_line = ','.join([
                f'"{cell}"' if ',' in str(cell) else str(cell)  # カンマを含む場合はクォートで囲む
                for cell in row
            ])
            # f-string（フォーマット文字列）：{変数}で値を埋め込める
            self.preview_text.insert(tk.END, f"[{i+1:3d}行目] {csv_line}\n")
            # {:3d} = 3桁右寄せで数値を表示
        
        # 10行を超える場合は省略表示
        if len(data) > max_preview_rows:
            self.preview_text.insert(tk.END, f"\n... 他 {len(data) - max_preview_rows} 行")
    
    # ============================================================================
    # 7. メイン処理（変換実行）
    # ============================================================================
    
    def convert_file(self):
        """
        ファイル変換を実行（メイン処理）
        """
        # 入力チェック
        if not self.input_file_path.get():
            messagebox.showwarning("警告", "入力ファイルを選択してください。")
            return
        
        if not self.output_file_path.get():
            messagebox.showwarning("警告", "出力ファイルを指定してください。")
            return
        
        try:
            self.status_var.set("変換中...")
            self.root.update()
            
            # プレビューデータがある場合はそれを使用、なければ解析実行
            if not self.preview_data:
                self.update_preview()  # プレビューを生成
            
            data = self.preview_data
            if not data:
                return
            
            # CSV出力
            with open(self.output_file_path.get(), 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)  # CSVライター作成
                # newline='' はWindowsでの改行問題を回避するため
                
                # ヘッダー行を書き込み
                if self.headers.get():
                    headers = [h.strip() for h in self.headers.get().split(',')]
                    writer.writerow(headers)
                
                # データ行を書き込み
                for row in data:
                    writer.writerow(row)
            
            # 成功メッセージ
            self.status_var.set(f"変換完了: {len(data)}行のデータを出力しました。")
            messagebox.showinfo("完了", f"変換が完了しました。\n出力ファイル: {self.output_file_path.get()}")
            
        except Exception as e:
            messagebox.showerror("エラー", f"変換中にエラーが発生しました: {e}")
            self.status_var.set("エラーが発生しました。")
    
    # ============================================================================
    # 8. ユーティリティメソッド（便利機能）
    # ============================================================================
    
    def clear_all(self):
        """
        全ての入力項目をクリア
        """
        self.input_file_path.set("")
        self.output_file_path.set("")
        self.delimiter.set("")
        self.pattern.set("")
        self.widths.set("")
        self.headers.set("")
        self.preview_text.delete(1.0, tk.END)
        self.preview_data = []
        self.status_var.set("クリアしました。")
    
    def load_sample(self):
        """
        サンプルデータを読み込み（テスト用）
        
        【デバッグ技術】
        開発中やテスト時に、毎回ファイルを選択するのは面倒。
        サンプルデータ機能で効率的にテストできる。
        """
        # サンプルテキストデータ
        sample_text = """名前	年齢	職業	部署
田中太郎	30	エンジニア	開発部
佐藤花子	25	デザイナー	企画部
山田次郎	35	営業	営業部
鈴木美咲	28	マーケター	マーケティング部"""
        
        # サンプルファイルを作成
        sample_file = "sample_data.txt"
        with open(sample_file, 'w', encoding='utf-8') as f:
            f.write(sample_text)
        
        # 設定を自動入力
        self.input_file_path.set(sample_file)
        self.output_file_path.set("sample_output.csv")
        self.parse_mode.set("structured")
        self.headers.set("名前,年齢,職業,部署")
        
        # プレビューを表示
        self.update_preview()
        self.status_var.set("サンプルデータを読み込みました。")

# ============================================================================
# 9. メイン実行部分
# ============================================================================

def main():
    """
    メイン関数：アプリケーションの起動処理
    
    【なぜmain関数を作るのか？】
    1. コードの構造が分かりやすい
    2. import時に実行されることを防ぐ
    3. 関数内の変数はローカルスコープに限定される
    """
    root = tk.Tk()  # メインウィンドウを作成
    app = TextToCSVConverterGUI(root)  # アプリケーションクラスのインスタンス作成
    
    # スタイル設定（見た目を良くする）
    style = ttk.Style()
    # カスタムスタイルが存在しない場合のみ作成
    if "Accent.TButton" not in style.theme_names():
        style.configure("Accent.TButton", foreground="white", background="blue")
    
    root.mainloop()  # GUIイベントループ開始（ユーザー操作を待ち続ける）

# ============================================================================
# 10. スクリプト実行時の処理
# ============================================================================

if __name__ == '__main__':
    """
    このスクリプトが直接実行された場合のみmain()を呼び出す
    
    【__name__ == '__main__' とは？】
    - 直接実行：python script.py → __name__ は '__main__'
    - import：import script → __name__ は 'script'
    この仕組みで、importした時に勝手に実行されることを防ぐ
    """
    main()

# ============================================================================
# 【新人エンジニアへの学習ガイド】
# ============================================================================

"""
🎓 このコードから学べるPythonの基本概念：

1. 【クラス設計】
   - __init__ メソッド（初期化）
   - インスタンス変数（self.xxx）
   - メソッドの分割（機能ごとに整理）

2. 【GUI プログラミング】
   - tkinter の基本的な使い方
   - イベント処理（ボタンクリック等）
   - レイアウト管理（grid, pack）

3. 【ファイル処理】
   - with open() 文の正しい使い方
   - エンコーディングの重要性
   - パス操作（pathlib）

4. 【エラーハンドリング】
   - try-except 文
   - 適切なエラーメッセージ
   - ユーザビリティを考慮した処理

5. 【文字列処理】
   - split, strip, join などの基本メソッド
   - 正規表現の活用
   - f-string（フォーマット文字列）

6. 【型ヒント】
   - List[List[str]] などの型注釈
   - コードの可読性向上

🚀 次のステップ：
- 他の GUI ライブラリ（PyQt, wxPython）を試す
- データベース連携機能を追加
- 非同期処理で大容量ファイルに対応
- テストコードを書く（unittest, pytest）
- パッケージ化（setuptools）

💡 実務での活用：
- 業務効率化ツールの作成
- データ変換・クリーニング処理
- レポート生成の自動化
- レガシーシステムとの連携

頑張って学習を続けてください！🎯
"""
